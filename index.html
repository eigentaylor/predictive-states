<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State Election Prediction Ranker</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Dark mode defaults and overrides for commonly used Tailwind utility classes in this file */
      /* Apply a dark background and lighter text when the body has class "dark" */
      body.dark {
        background-color: #071022; /* page base */
        color: #e6eef8;
      }

      /* Background utility overrides */
      body.dark .bg-gray-50 { background-color: #071022 !important; }
      body.dark .bg-white { background-color: #07162a !important; }
      body.dark .bg-gray-100 { background-color: #0b1726 !important; }
      body.dark .bg-gray-200 { background-color: #112233 !important; }

      /* Text color overrides */
      body.dark .text-gray-800 { color: #e6eef8 !important; }
      body.dark .text-gray-700 { color: #cbd5e1 !important; }
      body.dark .text-gray-600 { color: #94a3b8 !important; }
      body.dark .text-gray-500 { color: #6b7280 !important; }

      /* Input range styling in dark */
      body.dark input[type="range"] {
        background: #1f2937 !important;
      }

      /* Slightly soften shadows in dark mode */
      body.dark .shadow-md { box-shadow: 0 4px 10px rgba(2,6,23,0.6) !important; }
      body.dark .shadow-lg { box-shadow: 0 8px 24px rgba(2,6,23,0.65) !important; }

      /* Ensure state cards with colored backgrounds still read well on dark */
      body.dark .bg-blue-500 { box-shadow: 0 2px 6px rgba(59,130,246,0.18) inset; }
      body.dark .bg-purple-500 { box-shadow: 0 2px 6px rgba(139,92,246,0.18) inset; }
    </style>
</head>
<body class="dark">
    <div id="root"></div>

    <!-- Include your state data -->
    <script src="state_results.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // Election data structure
        const electionData = {
            years: Array.from({ length: (2024 - 1900) / 4 + 1 }, (_, i) => 1900 + i * 4),
          
          // Popular vote winners by year
          popularVoteWinners: {
            1900: 'R', 1904: 'R', 1908: 'R', 1912: 'D', 1916: 'D', 1920: 'R', 1924: 'R', 1928: 'R',
            1932: 'D', 1936: 'D', 1940: 'D', 1944: 'D', 1948: 'D', 1952: 'R', 1956: 'R', 1960: 'D',
            1964: 'D', 1968: 'R', 1972: 'R', 1976: 'D', 1980: 'R', 1984: 'R', 1988: 'R', 1992: 'D',
            1996: 'D', 2000: 'D', 2004: 'R', 2008: 'D', 2012: 'D', 2016: 'D', 2020: 'D', 2024: 'R'
          },
          
          // Electoral vote winners by year (differs from PV in 2000, 2016)
          electoralVoteWinners: {
            1900: 'R', 1904: 'R', 1908: 'R', 1912: 'D', 1916: 'D', 1920: 'R', 1924: 'R', 1928: 'R',
            1932: 'D', 1936: 'D', 1940: 'D', 1944: 'D', 1948: 'D', 1952: 'R', 1956: 'R', 1960: 'D',
            1964: 'D', 1968: 'R', 1972: 'R', 1976: 'D', 1980: 'R', 1984: 'R', 1988: 'R', 1992: 'D',
            1996: 'D', 2000: 'R', 2004: 'R', 2008: 'D', 2012: 'D', 2016: 'R', 2020: 'D', 2024: 'R'
          },
          
          // Use the imported state data
          states: window.stateData?.states || {}
        };

        const StateCard = ({ state, rank, accuracy, correct, total, type, isAnimating }) => {
          const percentage = (accuracy * 100).toFixed(1);
          const bgColor = type === 'pv' ? 'bg-blue-500' : 'bg-purple-500';
          const borderColor = type === 'pv' ? 'border-blue-300' : 'border-purple-300';
          
          return (
            <div 
              className={`
                ${bgColor} text-white p-2 sm:p-3 lg:p-4 m-1 sm:m-2 rounded-lg shadow-lg
                border-2 ${borderColor}
                transform transition-all duration-500 ease-out
                ${isAnimating ? 'animate-bounce scale-105' : 'hover:scale-102'}
                min-h-[60px] sm:min-h-[70px] lg:min-h-[80px] flex items-center justify-between
              `}
              style={{
                transitionDelay: `${rank * 50}ms`
              }}
            >
              <div className="flex-shrink-0">
                <div className="text-sm sm:text-base lg:text-lg font-bold">#{rank}</div>
                <div className="text-xs sm:text-sm opacity-80">
                  {correct}/{total}
                  <span className="hidden sm:inline"> ({percentage}%)</span>
                  <span className="sm:hidden"><br/>({percentage}%)</span>
                </div>
              </div>
              <div className="text-right min-w-0 flex-1 ml-2">
                <div className="text-sm sm:text-lg lg:text-xl font-semibold truncate">{state}</div>
              </div>
            </div>
          );
        };

        const RangeSlider = ({ label, min, max, value, onChange }) => {
          // For mobile: show a select dropdown (easier to pick exact year)
          const options = electionData.years.filter(y => y >= min && y <= max);
          return (
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                {label}: {value}
              </label>

              {/* Slider visible on md+ screens */}
              <input
                type="range"
                min={min}
                max={max}
                step={4}
                value={value}
                onChange={(e) => onChange(parseInt(e.target.value))}
                className="hidden md:block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
              />

              {/* Dropdown for mobile (visible below md) */}
              <select
                value={value}
                onChange={(e) => onChange(parseInt(e.target.value))}
                className="block md:hidden w-full mt-2 p-2 bg-white rounded border border-gray-300"
              >
                {options.map((y) => (
                  <option key={y} value={y}>{y}</option>
                ))}
              </select>
            </div>
          );
        };

        function StatePredictionVisualizer() {
          const [startYear, setStartYear] = useState(1900);
          const [endYear, setEndYear] = useState(2024);
          const [isAnimating, setIsAnimating] = useState(false);

          const minYear = Math.min(...electionData.years);
          const maxYear = Math.max(...electionData.years);

          // Calculate accuracy scores for each state in the given range
          const calculateAccuracy = useMemo(() => {
            const validYears = electionData.years.filter(year => year >= startYear && year <= endYear);

            const stats = [];

            Object.entries(electionData.states).forEach(([stateName, stateVotes]) => {
              let pvCorrect = 0;
              let evCorrect = 0;
              let stateElections = 0;

              validYears.forEach(year => {
                if (stateVotes[year]) {
                  stateElections++; // Count all elections the state participated in
                  if (stateVotes[year] === electionData.popularVoteWinners[year]) pvCorrect++;
                  if (stateVotes[year] === electionData.electoralVoteWinners[year]) evCorrect++;
                }
              });

              if (stateElections > 0) {
                stats.push({
                  state: stateName,
                  pvCorrect,
                  evCorrect,
                  total: stateElections,
                  pvAccuracy: pvCorrect / stateElections,
                  evAccuracy: evCorrect / stateElections
                });
              }
            });

            // Helper to compare floats with small epsilon
            const eq = (a, b) => Math.abs(a - b) < 0.0005;

            // PV rankings: primary pvAccuracy desc, secondary evAccuracy desc, tertiary state name
            const pvSorted = [...stats].sort((a, b) => {
              if (!eq(a.pvAccuracy, b.pvAccuracy)) return b.pvAccuracy - a.pvAccuracy;
              if (!eq(a.evAccuracy, b.evAccuracy)) return b.evAccuracy - a.evAccuracy;
              return a.state.localeCompare(b.state);
            });

            // Assign ranks with ties sharing the same rank (standard competition ranking: 1,1,3)
            const pvRankings = [];
            let prevPV = null;
            let prevEV = null;
            let prevRank = 0;
            pvSorted.forEach((item, i) => {
              // Tie by primary metric only (pvAccuracy). Keep secondary sort for ordering
              // but do not use it to break ties for ranking.
              if (prevPV !== null && eq(item.pvAccuracy, prevPV)) {
                // same primary accuracy as previous -> same rank
                pvRankings.push({ ...item, rank: prevRank });
              } else {
                const rank = i + 1;
                pvRankings.push({ ...item, rank });
                prevRank = rank;
                prevPV = item.pvAccuracy;
                prevEV = item.evAccuracy;
              }
            });

            // EV rankings: primary evAccuracy desc, secondary pvAccuracy desc, tertiary state name
            const evSorted = [...stats].sort((a, b) => {
              if (!eq(a.evAccuracy, b.evAccuracy)) return b.evAccuracy - a.evAccuracy;
              if (!eq(a.pvAccuracy, b.pvAccuracy)) return b.pvAccuracy - a.pvAccuracy;
              return a.state.localeCompare(b.state);
            });

            const evRankings = [];
            prevPV = null;
            prevEV = null;
            prevRank = 0;
            evSorted.forEach((item, i) => {
              // Tie by primary metric only (evAccuracy). Keep secondary sort for ordering
              // but do not use it to break ties for ranking.
              if (prevEV !== null && eq(item.evAccuracy, prevEV)) {
                evRankings.push({ ...item, rank: prevRank });
              } else {
                const rank = i + 1;
                evRankings.push({ ...item, rank });
                prevRank = rank;
                prevEV = item.evAccuracy;
                prevPV = item.pvAccuracy;
              }
            });

            return { pvRankings, evRankings };
          }, [startYear, endYear]);

          // Trigger animation when rankings change
          useEffect(() => {
            setIsAnimating(true);
            const timer = setTimeout(() => setIsAnimating(false), 1000);
            return () => clearTimeout(timer);
          }, [startYear, endYear]);

          const validElectionCount = electionData.years.filter(year => year >= startYear && year <= endYear).length;

          return (
            <div className="min-h-screen bg-gray-50 p-6">
              <div className="max-w-7xl mx-auto">
                <div className="text-center mb-8">
                  <h1 className="text-4xl font-bold text-gray-800 mb-2">
                    State Election Prediction Visualizer
                  </h1>
                  <p className="text-lg text-gray-600">
                    Ranking states by their accuracy in predicting presidential election winners
                  </p>
                  <p className="text-sm text-gray-500 mt-2">
                    Analyzing {validElectionCount} elections from {startYear} to {endYear}
                  </p>
                </div>
                
                {/* Controls */}
                <div className="bg-white rounded-lg shadow-md p-6 mb-8">
                  <h2 className="text-xl font-semibold mb-4">Time Range Selection</h2>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <RangeSlider
                      label="Start Year"
                      min={minYear}
                      max={maxYear - 4}
                      value={startYear}
                      onChange={setStartYear}
                    />
                    <RangeSlider
                      label="End Year"
                      min={startYear + 4}
                      max={maxYear}
                      value={endYear}
                      onChange={setEndYear}
                    />
                  </div>
                </div>

                {/* Rankings */}
                <div className="grid grid-cols-2 gap-2 sm:gap-4 lg:gap-8">
                  {/* Popular Vote Rankings */}
                  <div className="bg-white rounded-lg shadow-md p-2 sm:p-4 lg:p-6">
                    <h2 className="text-lg sm:text-xl lg:text-2xl font-bold text-blue-600 mb-2 lg:mb-4 text-center">
                      Popular Vote Prediction Accuracy
                    </h2>
                    <p className="text-xs sm:text-sm text-gray-600 mb-2 lg:mb-4 text-center">
                      States ranked by how often they voted for the popular vote winner
                    </p>
                    <div className="space-y-1 sm:space-y-2">
                      {calculateAccuracy.pvRankings.map((ranking) => (
                        <StateCard
                          key={`pv-${ranking.state}`}
                          state={ranking.state}
                          rank={ranking.rank}
                          accuracy={ranking.pvAccuracy}
                          correct={ranking.pvCorrect}
                          total={ranking.total}
                          type="pv"
                          isAnimating={isAnimating}
                        />
                      ))}
                    </div>
                  </div>

                  {/* Electoral Vote Rankings */}
                  <div className="bg-white rounded-lg shadow-md p-2 sm:p-4 lg:p-6">
                    <h2 className="text-lg sm:text-xl lg:text-2xl font-bold text-purple-600 mb-2 lg:mb-4 text-center">
                      Electoral Vote Prediction Accuracy
                    </h2>
                    <p className="text-xs sm:text-sm text-gray-600 mb-2 lg:mb-4 text-center">
                      States ranked by how often they voted for the electoral vote winner
                    </p>
                    <div className="space-y-1 sm:space-y-2">
                      {calculateAccuracy.evRankings.map((ranking) => (
                        <StateCard
                          key={`ev-${ranking.state}`}
                          state={ranking.state}
                          rank={ranking.rank}
                          accuracy={ranking.evAccuracy}
                          correct={ranking.evCorrect}
                          total={ranking.total}
                          type="ev"
                          isAnimating={isAnimating}
                        />
                      ))}
                    </div>
                  </div>
                </div>

                {/* About */}
                <div className="mt-8 bg-gray-100 rounded-lg p-6">
                  <h3 className="text-lg font-semibold mb-2">About the Data</h3>
                  <p className="text-sm text-gray-700 mb-2">
                    This visualization uses complete historical data for all 50 states plus D.C. from 1900-2024. 
                    Third-party winners (marked as 'T') count as incorrect predictions since they don't 
                    match either the Republican or Democratic national winners.
                  </p>
                  <p className="text-sm text-gray-700">
                    Notable discrepancies: Electoral College winners differed from Popular Vote winners in 
                    <strong> 2000</strong> (Bush vs Gore) and <strong> 2016</strong> (Trump vs Clinton), 
                    creating different accuracy rankings between the two metrics.
                  </p>
                </div>
              </div>
            </div>
          );
        }

        // Render the app
        ReactDOM.render(<StatePredictionVisualizer />, document.getElementById('root'));
    </script>
</body>
</html>